<!DOCTYPE html>
<html>
<head>
    <script src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <script src="https://cdn.jsdelivr.net/jstat/latest/jstat.min.js"></script>
    <script src="https://unpkg.com/vue"></script>
    <script src="distributions.js"></script>
    <script src="charts.js"></script>
    <link rel="stylesheet" type="text/css" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
</head>
<body>
    <div id="app">{{message}}</div>
    
<p>
<table><tr>
    <td><select id="countries_available" multiple style="width: 20em; height: 10em"></select></td>
    <td><table>
        <tr><td><input type="button" id="removeall" value="<<"></input></td></tr>
        <tr><td><input type="button" id="remove" value="<"></input></td></tr>
        <tr><td><input type="button" id="add" value=">"></input></td></tr>
        <tr><td><input type="button" id="addall" value=">>"></input></td></tr>
    </table></td>
    <td>
        <select id="countries_selected" multiple style="width: 20em; height: 10em"></select>
    </td>
</tr><tr>
    <td><input type="checkbox" id="stacked" value="Stacked">Stacked</input></td>
</tr><tr>
    <td colspan=3>Year: <span id="year_label"></span> <div id="year"></div> </td>
</tr></table>
</p>
<div id="pdf" width="400" height="400"></div>
<!--
<svg id="histogram" width="400" height="400"></svg>
<svg id="cdf" width="400" height="400"></svg>
<svg id="quantile" width="400" height="400"></svg>
<svg id="lorenz" width="400" height="400"></svg>
<svg id="deciles" width="400" height="400"></svg>
-->
</body>
<script>
    
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})

var countries = new Map();
var populations = new Map();
var selection = new Set();

d3.json("distributions.json?nocache=" + (new Date()).getTime(), function(data) {
    d3.csv("population.csv", function(popdata) {
        popdata.forEach(function (d) {
            key = d['Country Code'];
            if (!populations.has(key))
                populations.set(key, new Map());
                
            for (year = 1960; year <= 2015; year++)
                populations.get(key).set(year, +d[year]);
        });
        
        data.forEach(function (svy, i) {
            if (svy.iso3c == "KSV")
                svy.iso3c = "XKX"
            if (svy.iso3c == "TMP")
                svy.iso3c = "TLS"
            if (svy.iso3c == "WBG")
                svy.iso3c = "PSE"
            if (svy.iso3c == "ZAR")
                svy.iso3c = "COD"
            key = svy.iso3c + "-" + svy.source.substring(4,5) + "-" + svy.measure;
            //console.log(key, svy.source);
            if (!countries.has(key)) {
                countries.set(key, new Map());
            }
            var popn = populations.get(svy.iso3c).get(svy.year);
            var dist = new LinearSplinePDFIncomeDistribution(popn, svy.distribution.y, svy.distribution.fy);
            countries.get(key).set(svy.year, dist);
        });
    
        countries.forEach(function(series, key, map) {
            // Add country series to dropdown
            $('#countries_available').append($('<option>', {value: key, text: key})); 
        
            var years = Array.from(series.keys()).sort();
            for (var i = 0; i < years.length - 1; i++) {
                var dist_a = series.get(years[i]);
                var dist_b = series.get(years[i+1]);
            
                for (year = years[i] + 1; year < years[i+1]; year++) {
                    var dist = LinearSplinePDFIncomeDistribution.convex_combination(
                        dist_a,
                        dist_b,
                        (year - years[i]) / (years[i+1] - years[i]),
                        populations.get(key.substring(0,3)).get(year)
                    );
                    series.set(year, dist);
                }
            }
        });
    });
});

$("#countries_available").dblclick(function() {$("#add").trigger("click")});
$("#countries_selected").dblclick(function() {$("#remove").trigger("click")});
$("#add").click(function () {
    $('#countries_available').val().forEach(function(key) {
        selection.add(key); 
    });
    update();
});

$("#remove").click(function () {
    $('#countries_selected').val().forEach(function(key) {
        selection.delete(key); 
    });
    update();
});
$("#addall").click(function () {
    $('#countries_available option').prop('selected', true);
    $("#add").trigger("click");
});

$("#removeall").click(function () {
    $('#countries_selected option').prop('selected', true);
    $("#remove").trigger("click");
});


function update() {
    series = [];
    var min_year = -9999, max_year = 9999;
    
    $("#countries_selected").find('option').remove().end();
    selection.forEach(function(key) {
        c = countries.get(key);
        years = Array.from(c.keys()).sort();
        min_year = Math.max(min_year, years[0]);
        max_year = Math.min(max_year, years[years.length-1]);
        series.push(c);
        $('#countries_selected').append($('<option>', {value: key, text: key + " (" + years[0] + "-" + years[years.length-1] + ")"}));
    });

    console.log("series", series);

    years = Array.from(years).sort();
    
    $( "#year" ).slider({
        min: min_year,
        max: max_year,
        value: $('#year').data("uiSlider") ? $('#year').slider("value") : min_year,
        slide: function() {
            year = $(this).slider("value")
            $("#year_label").text(year); //+ " (" + dist1.fx.length + ")");
            updateDists(series, year, $("stacked").val());
        },
        change: function() {
            year = $(this).slider("value")
            $("#year_label").text(year); //+ " (" + dist1.fx.length + ")");
            updateDists(series, year, $("stacked").val());
        },
        create: function() {
            $(this).slider("value", min_year);
        }
    });
    
    //console.log("xlim", Math.max(...Array.from(series).map(s => Math.max(...Array.from(s.values()).map(d => d.inv(0.95))))));
    
    chart
        .xlim([0, Math.max(...Array.from(series).map(s => Math.max(...Array.from(s.values()).map(d => d.inv(0.95)))))])
        .ylim([0, Math.max(...Array.from(series).map(s => Math.max(...Array.from(s.values()).map(d => d.pdf_max(true)))))]);
    
}

var chart = pdfChart()
    .x(d => d.x)
    .y(d => d.pdf)

function updateDists(series, year, isStacked) {
    dists = [];
    for (var i = 0; i < series.length; i++) {
        if (series[i].has(year)) {
            dists.push(series[i].get(year));
        }
    }
    if (dists.length > 1) {
        timeit("[LinearSplinePDFIncomeDistribution.aggregate(dists)];");
        series = [LinearSplinePDFIncomeDistribution.aggregate(dists)];
        //console.log("combined");
        //console.log(series[0]);
    } else {
        series = dists;
    }
    
    d3.select("#pdf")
        .datum(series)
        .call(chart);
}
/******************************************************************************
* PDF
******************************************************************************/
/*
var svg = d3.select("svg#pdf"),
    width = +svg.attr("width"),
    height = +svg.attr("height"),
    margin = {top: 20, right: 30, bottom: 30, left: 40};

function updateDists(dist, dist2) {
    updatePDFs(dist, dist2);
}

function updatePDFs(dist, dist2) {
    margin = window.margin;
    svg = window.svg;

    var x = d3.scaleLinear()
    //var x = d3.scaleLog().base(10)
        .domain([dist.inv(0.001),dist.inv(0.99)])
        .range([margin.left, width - margin.right]);

    var grid = dist.grid(1000, false, x.domain());
    var grid2 = dist2.grid(1000, false, x.domain());

    var y = d3.scaleLinear()
        .domain([0, Math.max(...grid.map(d => d.pdf))])
        .range([height - margin.bottom, margin.top]);

    svg.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + (height - margin.bottom) + ")")
        .call(d3.axisBottom(x));

    svg.append("g")
        .attr("class", "axis axis--y")
        .attr("transform", "translate(" + margin.left + ",0)")
        .call(d3.axisLeft(y).ticks(null, ".1e"));

    var path = svg.selectAll("path").datum(grid);
    
    path.enter().append("path")
        .datum(grid)
        .attr("fill", "none")
        .attr("stroke", "blue")
        .attr("stroke-width", 1.5)
        .attr("stroke-linejoin", "round")
        .attr("d", d3.line()
        .x(function(d) { return x(d.x); })
        .y(function(d) { return y((d.pdf)); }));

    path.exit().remove();

    svg.append("text")
        .attr("x", margin.left+(width-margin.left-margin.right)/2)             
        .attr("y", margin.top * 2)
        .attr("text-anchor", "middle")  
        .style("font-size", "16px") 
        .text("PDF");
    
}
*/    
    
    
    
    
    
    
    
    
    
function nothing() {
 /******************************************************************************
 * CDF
 ******************************************************************************/
 var svg = d3.select("svg#cdf"),
     width = +svg.attr("width"),
     height = +svg.attr("height"),
     margin = {top: 20, right: 30, bottom: 30, left: 40};

 var x = d3.scaleLinear()
     .domain([dist.inv(0.001),dist.inv(0.99)])
     .range([margin.left, width - margin.right]);

 var grid = dist.grid(1000, false, x.domain());
 var grid2 = dist2.grid(1000, false, x.domain());

 var y = d3.scaleLinear()
     .domain([0, 1])
     .range([height - margin.bottom, margin.top]);

 svg.append("g")
     .attr("class", "axis axis--x")
     .attr("transform", "translate(0," + (height - margin.bottom) + ")")
     .call(d3.axisBottom(x));

 svg.append("g")
     .attr("class", "axis axis--y")
     .attr("transform", "translate(" + margin.left + ",0)")
     .call(d3.axisLeft(y));

  svg.append("path")
       .datum(grid)
       .attr("fill", "none")
       .attr("stroke", "blue")
       .attr("stroke-width", 1.5)
       .attr("stroke-linejoin", "round")
       .attr("d", d3.line()
         //.curve(d3.curveCardinal)
      .x(function(d) { return x(d.x); })
         .y(function(d) { return y((d.cdf)); }));

  svg.append("path")
       .datum(grid2)
       .attr("fill", "none")
       .attr("stroke", "red")
       .attr("stroke-width", 1.5)
       .attr("stroke-linejoin", "round")
       .attr("d", d3.line()
         //.curve(d3.curveCardinal)
      .x(function(d) { return x(d.x); })
         .y(function(d) { return y((d.cdf)); }));
       
 svg.append("text")
        .attr("x", margin.left+(width-margin.left-margin.right)/2)             
        .attr("y", margin.top * 2)
        .attr("text-anchor", "middle")  
        .style("font-size", "16px") 
         .text("CDF");

       
 /******************************************************************************
 * Quantile
 ******************************************************************************/
var svg = d3.select("svg#quantile"),
 width = +svg.attr("width"),
 height = +svg.attr("height"),
 margin = {top: 20, right: 30, bottom: 30, left: 40};

var x = d3.scaleLinear()
 .domain([0, 1])
 .range([margin.left, width - margin.right]);
 
var xgrid = [];
for (var i = 0; i < 1; i += 1/1000) {
    xgrid.push(i);
}

var grid = d3.transpose([xgrid, dist.inv(xgrid)]);
var grid2 = d3.transpose([xgrid, dist2.inv(xgrid)]);

var y = d3.scaleLinear()
 .domain([0, dist.inv(0.999)])
 .range([height - margin.bottom, margin.top]);

svg.append("g")
 .attr("class", "axis axis--x")
 .attr("transform", "translate(0," + (height - margin.bottom) + ")")
 .call(d3.axisBottom(x));

svg.append("g")
 .attr("class", "axis axis--y")
 .attr("transform", "translate(" + margin.left + ",0)")
 .call(d3.axisLeft(y));

svg.append("path")
   .datum(grid)
   .attr("fill", "none")
   .attr("stroke", "blue")
   .attr("stroke-width", 1.5)
   .attr("stroke-linejoin", "round")
   .attr("d", d3.line()
     //.curve(d3.curveCardinal)
  .x(function(d) { return x(d[0]); })
     .y(function(d) { return y((d[1])); }));
     
svg.append("path")
   .datum(grid2)
   .attr("fill", "none")
   .attr("stroke", "red")
   .attr("stroke-width", 1.5)
   .attr("stroke-linejoin", "round")
   .attr("d", d3.line()
     
     //.curve(d3.curveCardinal)
  .x(function(d) { return x(d[0]); })
     .y(function(d) { return y((d[1])); }));
svg.append("text")
        .attr("x", margin.left+(width-margin.left-margin.right)/2)             
        .attr("y", margin.top * 2)
        .attr("text-anchor", "middle")  
        .style("font-size", "16px") 
        .text("Quantile function");

 /******************************************************************************
 * Lorenz
 ******************************************************************************/
var svg = d3.select("svg#lorenz"),
 width = +svg.attr("width"),
 height = +svg.attr("height"),
 margin = {top: 20, right: 30, bottom: 30, left: 40};

var x = d3.scaleLinear()
 .domain([0, 1])
 .range([margin.left, width - margin.right]);

var xgrid = [];
for (var i = 0; i < 1; i += 1/1000) {
    xgrid.push(i);
}

var grid = d3.transpose([xgrid, dist.lorenz(xgrid)]);
var grid2 = d3.transpose([xgrid, dist2.lorenz(xgrid)]);

var y = d3.scaleLinear()
 .domain([0, Math.max(...grid.map(d => d[1]))])
 .range([height - margin.bottom, margin.top]);

svg.append("g")
 .attr("class", "axis axis--x")
 .attr("transform", "translate(0," + (height - margin.bottom) + ")")
 .call(d3.axisBottom(x));

svg.append("g")
 .attr("class", "axis axis--y")
 .attr("transform", "translate(" + margin.left + ",0)")
 .call(d3.axisLeft(y));

svg.append("path")
   .datum(grid)
   .attr("fill", "none")
   .attr("stroke", "blue")
   .attr("stroke-width", 1.5)
   .attr("stroke-linejoin", "round")
   .attr("d", d3.line()
     //.curve(d3.curveCardinal)
  .x(function(d) { return x(d[0]); })
     .y(function(d) { return y((d[1])); }));
     
svg.append("path")
   .datum(grid2)
   .attr("fill", "none")
   .attr("stroke", "red")
   .attr("stroke-width", 1.5)
   .attr("stroke-linejoin", "round")
   .attr("d", d3.line()
     //.curve(d3.curveCardinal)
  .x(function(d) { return x(d[0]); })
     .y(function(d) { return y((d[1])); }));

svg.append("text")
        .attr("x", margin.left+(width-margin.left-margin.right)/2)             
        .attr("y", margin.top * 2)
        .attr("text-anchor", "middle")  
        .style("font-size", "16px") 
        .text("Lorenz curve (not normalized to mean)");

 /******************************************************************************
 * Deciles
 ******************************************************************************/
     
 var domain = ["bottom 10%", "10-20%","20-30%","30-40%","40-50%","50-60%","60-70%","70-80%","80-90%","top 10%"];

 var deciles = d3.transpose([
     domain, 
     dist.deciles()
 ]);

 var deciles2 = d3.transpose([
     domain, 
     dist2.deciles()
 ]);

 var svg = d3.select("svg#deciles"),
     width = +svg.attr("width"),
     height = +svg.attr("height"),
     margin = {top: 20, right: 30, bottom: 70, left: 40};

 var x = d3.scaleBand()
     .domain(domain)
     .rangeRound([margin.left, width - margin.right])
     .padding(0.1);

 var y = d3.scaleLinear()
     .domain([0, Math.max(...deciles.map(d => d[1]))])
     .range([height - margin.bottom, margin.top]);


 svg.append("g")
     .attr("class", "axis axis--x")
     .attr("transform", "translate(0," + (height - margin.bottom) + ")")
     .call(d3.axisBottom(x))
     .selectAll("text")
     .attr("y", 0)
     .attr("x", 9)
     .attr("dy", ".35em")
     .attr("transform", "rotate(90)")
     .style("text-anchor", "start");
     
 svg.append("g")
     .attr("class", "axis axis--y")
     .attr("transform", "translate(" + margin.left + ",0)")
     .call(d3.axisLeft(y).ticks(null, "s"));

  svg.insert("g", "*")
      .attr("fill", "blue")
     .attr("opacity", 0.5)
    .selectAll("rect")
    .data(deciles)
    .enter().append("rect")
      .attr("x", function(d) { return x(d[0]); })
      .attr("y", function(d) { return y(d[1]); })
     .attr("width", x.bandwidth())
      .attr("height", function(d) { return (y(0) - y(d[1])); });

  svg.insert("g", "*")
      .attr("fill", "red")
     .attr("opacity", 0.5)
    .selectAll("rect")
    .data(deciles2)
    .enter().append("rect")
      .attr("x", function(d) { return x(d[0]); })
      .attr("y", function(d) { return y(d[1]); })
     .attr("width", x.bandwidth())
      .attr("height", function(d) { return (y(0) - y(d[1])); });

svg.append("text")
        .attr("x", margin.left+(width-margin.left-margin.right)/2)             
        .attr("y", margin.top * 2)
        .attr("text-anchor", "middle")  
        .style("font-size", "16px") 
        .text("Mean by deciles");
        
    /******************************************************************************
    * Histogram
    ******************************************************************************/

    var x = d3.scaleLinear()
        .domain([dist.inv(0.001),dist.inv(0.99)])
        .range([margin.left, width - margin.right]);

    var hist = dist.histogram(50, true, x.domain());
    var hist2 = dist2.histogram(50, true, x.domain());

    var y = d3.scaleLinear()
        .domain([0, Math.max(...hist.map(d => d.hist))])
        .range([height - margin.bottom, margin.top]);

    var svg = d3.select("svg#histogram"),
        width = +svg.attr("width"),
        height = +svg.attr("height"),
        margin = {top: 20, right: 30, bottom: 30, left: 40};

    svg.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + (height - margin.bottom) + ")")
        .call(d3.axisBottom(x));

    svg.append("g")
        .attr("class", "axis axis--y")
        .attr("transform", "translate(" + margin.left + ",0)")
        .call(d3.axisLeft(y).ticks(null, "s"));

     svg.insert("g", "*")
         .attr("fill", "blue")
         .attr("opacity", 0.5)
       .selectAll("rect")
       .data(hist)
       .enter().append("rect")
         .attr("x", function(d) { return x(d.xmin) + 1; })
         .attr("y", function(d) { return y(d.hist); })
         .attr("width", function(d) { return x(d.xmax) - x(d.xmin) - 1; })
         .attr("height", function(d) { return (y(0) - y(d.hist)); });

     svg.insert("g", "*")
         .attr("fill", "red")
         .attr("opacity", 0.5)
       .selectAll("rect")
       .data(hist2)
       .enter().append("rect")
         .attr("class", "d2r")
         .attr("x", function(d) { return x(d.xmin) + 1; })
         .attr("y", function(d) { return y(d.hist); })
         .attr("width", function(d) { return x(d.xmax) - x(d.xmin) - 1; })
         .attr("height", function(d) { return (y(0) - y(d.hist)); });
     
    svg.append("text")
            .attr("x", margin.left+(width-margin.left-margin.right)/2)             
            .attr("y", margin.top * 2)
            .attr("text-anchor", "middle")  
            .style("font-size", "16px") 
            .text("Histogram");
}

//$('#gini').on('input',function() {
//    gini = $(this).val() ;
//
//    dist2 = new LogNormalIncomeDistribution(25e6, 563.573, gini/100);
//
//    var hist2 = dist2.histogram(50, true, x.domain());
//    var svg = d3.select("svg#histogram");
//    svg.selectAll("rect.d2r")
//        .data(hist2)
//        .transition(d3.transition().duration(50))
//        .attr("y", function(d) { return y(d.hist); })
//        .attr("height", function(d) { return (y(0) - y(d.hist)); });
// 
//     //rects.exit().remove();
// });

</script>